package test

import (
	"FuzzGIUPluginKit/cmd/common"
	"FuzzGIUPluginKit/convention"
	"FuzzGIUPluginKit/env"
	"encoding/json"
	"fmt"
	"github.com/nostalgist134/FuzzGIU/components/fuzzTypes"
	FGPlugin "github.com/nostalgist134/FuzzGIU/components/plugin"
	"github.com/spf13/cobra"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

var subCmdRun = &cobra.Command{
	Use:   "run",
	Short: "run test",
	Long: `run a test over a plugin
	since this command need to call plugin by arguments and its type, only plugins
	built with info(build -i) can be tested. there are 2 ways to test a plugin,
	expr(-e) and file(-f). 
	
	expr mode use the pseudo function call expression the same as fuzzGIU do to call a
	plugin. but the name of plugin will be ignored(because path of the plugin will be
	passed to fgpk by -p flag and it will use it). in this way, some types of plugin
	has struct argument will use empty structs. also you can't specify expect values
	for each test. however you can still specify multiple tests by one -e, each 
	seperated with comma.

	file mode use the test files generated by test gen command, for more information,
	run test gen -h.`,
	Run: runCmdRun,
}

func init() {
	subCmdRun.Flags().StringP("path", "p", "", "path of plugin binary file")
	subCmdRun.Flags().StringP("expr", "e", "",
		"run test via pseudo function calls(function name will be ignored)")
	subCmdRun.Flags().StringP("file", "f", "",
		"run test via test files(generated by gen command)")
	subCmdRun.Flags().StringP("out", "o", "", "output test result to a json file")
}

var testRecord = make([]ResultTest, 0)
var writeResultToFile = false

func recordTest(t any, result any, passed bool) {
	if !writeResultToFile {
		return
	}
	if p, ok := t.(fuzzTypes.Plugin); ok {
		testRecord = append(testRecord, ResultTest{
			T:      Test{Args: p.Args},
			Result: result,
			Passed: true,
		})
	} else if test, ok := t.(Test); ok {
		testRecord = append(testRecord, ResultTest{
			T:      test,
			Result: result,
			Passed: passed,
		})
	}
}

func writeTestTo(out string) {
	f, err := os.Create(out)
	if err != nil {
		fmt.Fprintf(os.Stderr, "can't create out file %s: %v. skip\n", out, err)
		return
	}
	defer f.Close()
	j, err := json.MarshalIndent(testRecord, "", "  ")
	if err != nil {
		fmt.Fprintf(os.Stderr, "can't marshal results: %v. skip\n", err)
		return
	}
	f.Write(j)
}

// callPluginByType 根据插件类型调用插件函数
func callPluginByType(pType string, p fuzzTypes.Plugin, predefinedArgs ...any) any {
	switch pType {
	case convention.PluginTypes[convention.IndPTypePlProc]:
		return FGPlugin.PayloadProcessor(p)
	case convention.PluginTypes[convention.IndPTypePlGen]:
		return FGPlugin.PayloadGenerator(p)
	case convention.PluginTypes[convention.IndPTypeReact]:
		var req *fuzzTypes.Req
		var resp *fuzzTypes.Resp
		// 若指定了固定参数列表，则使用指定的，否则使用默认值，下面也一样
		if len(predefinedArgs) > 1 {
			req = predefinedArgs[0].(*fuzzTypes.Req)
			resp = predefinedArgs[1].(*fuzzTypes.Resp)
		} else {
			req = convention.GetFullStruct("*fuzzTypes.Req").(*fuzzTypes.Req)
			resp = convention.GetFullStruct("*fuzzTypes.Resp").(*fuzzTypes.Resp)
		}
		return FGPlugin.React(p, req, resp)
	case convention.PluginTypes[convention.IndPTypeReqSender]:
		var sendMeta *fuzzTypes.SendMeta
		if len(predefinedArgs) != 0 {
			sendMeta = predefinedArgs[0].(*fuzzTypes.SendMeta)
		} else {
			sendMeta = convention.GetStruct("*fuzzTypes.SendMeta").(*fuzzTypes.SendMeta)
		}
		return FGPlugin.SendRequest(p, sendMeta)
	case convention.PluginTypes[convention.IndPTypePreproc]:
		var fuzz *fuzzTypes.Fuzz
		if len(predefinedArgs) != 0 {
			fuzz = predefinedArgs[0].(*fuzzTypes.Fuzz)
		} else {
			fuzz = convention.GetStruct("*fuzzTypes.Fuzz").(*fuzzTypes.Fuzz)
		}
		return FGPlugin.Preprocess(p, fuzz)
	}
	return nil
}

// cmpParaTypes 判断参数列表的类型是否完全对应，是返回true，否则返回false
func cmpParaTypes(p1 []any, p2 []convention.Param) bool {
	if len(p1) != len(p2) {
		return false
	}
	for i, p := range p1 {
		if reflect.TypeOf(p).String() != p2[i].Type {
			return false
		}
	}
	return true
}

// callPluginExpr 使用伪函数调用语句调用插件（plugin1("1",2,3),plugin1("abc"),...），无法指定固定参数或期望值，只能使用默认值
func callPluginExpr(callExpr string, pluginPath string) {
	// FGPlugin包不会检查路径，所以可以用路径穿越绕过加载目录限制，我也懒得再把包重构一遍了，就这么着吧
	// 获取插件文件相关信息，存储穿越前的路径和穿越后的路径
	pName := filepath.Base(pluginPath)
	pName = pName[:strings.LastIndex(pName, ".")]
	pName1 := filepath.Join("../../", pName)
	// 切换到插件所在目录
	cwd := env.GetCwd()
	err := os.Chdir(filepath.Dir(pluginPath))
	common.FailExit(err)
	defer os.Chdir(cwd)

	plugins := FGPlugin.ParsePluginsStr(callExpr)
	inf, err := common.GetPluginInfo(pluginPath)
	common.FailExit(err)
	fd := convention.BuildFd(inf)
	preDefinedArgs := convention.GetPreDefinedArgs(inf.Type)
	// 测试插件
	for i, p := range plugins {
		fmt.Println(strings.Repeat("-", 25))
		argListCmp := p.Args
		if preDefinedArgs != nil {
			argListCmp = append(preDefinedArgs, argListCmp...)
		}
		// 穿越前的路径用于输出
		p.Name = pName
		if !cmpParaTypes(argListCmp, fd.Params) {
			recordTest(p, nil, false)
			fmt.Fprintf(os.Stderr, "arglist#%d arguments does not match plugin's, skipping\n", i)
			continue
		}
		fmt.Printf("test on: %v\n", p)
		// 穿越后的路径用于调用
		p.Name = pName1
		result := callPluginByType(inf.Type, p)
		// 输出到文件
		p.Name = pName
		recordTest(p, result, true)
		fmt.Printf("result: %v\n", result)
	}
}

// callPluginTestFile 从文件中读取测试用例并执行
func callPluginTestFile(filePath string, pluginPath string) {
	pName := filepath.Base(pluginPath)
	pName = pName[:strings.LastIndex(pName, ".")]
	pName = filepath.Join("../../", pName)
	// 获取插件信息
	inf, err := common.GetPluginInfo(pluginPath)
	common.FailExit(err)
	fd := convention.BuildFd(inf)
	preDefinedArgs := convention.GetPreDefinedArgs(inf.Type)
	// 加载测试用例文件
	var tests []Test
	file, err := os.Open(filePath)
	common.FailExit(err)
	decoder := json.NewDecoder(file)
	// 使用json.Number类型表示数字，从而下面可以自动转换（json.Marshal默认对所有数字都是float64）
	decoder.UseNumber()
	err = decoder.Decode(&tests)
	common.FailExit(err)
	preNum := len(preDefinedArgs)
	for i, test := range tests {
		fmt.Println(strings.Repeat("-", 25))
		convertFail := false
		// 将map转为预定义参数对应的类型
		for j := 0; j < len(preDefinedArgs); j++ {
			b, _ := json.Marshal(test.Args[j])
			err = json.Unmarshal(b, preDefinedArgs[j])
			if err != nil {
				fmt.Fprintf(os.Stderr, "test#%d argument#%d conversion error: %v. skip\n", i, j, err)
				convertFail = true
				break
			}
			test.Args[j] = preDefinedArgs[j]
		}
		if convertFail {
			recordTest(test, nil, false)
			continue
		}
		// 将数字参数转换为正确的类型
		for j, a := range test.Args {
			switch v := a.(type) {
			case json.Number:
				if i64, err := v.Int64(); err == nil {
					test.Args[j] = int(i64)
				} else if f64, err := v.Float64(); err == nil {
					test.Args[j] = f64
				} else {
					test.Args[j] = v.String()
				}
			}
		}
		if !cmpParaTypes(test.Args, fd.Params) {
			fmt.Fprintf(os.Stderr, "test#%d arguments does not match plugin's, skip\n", i)
			continue
		}
		// 获取期望值（如果有）
		var expect any = nil
		if stru := convention.GetStruct(fd.RetType); test.Expect != nil && stru != nil {
			// 由json序列化对于any类型默认会转为map，需将map转为返回值对应的类型，并根据转换错误来判断类型是否匹配
			b, _ := json.Marshal(test.Expect)
			err = json.Unmarshal(b, stru)
			if err != nil {
				recordTest(test, nil, false)
				fmt.Fprintf(os.Stderr, "test#%d expect not match plugin's return type, skip comparation\n", i)
				continue
			}
			expect = stru
		} else if stru == nil && test.Expect != nil {
			// 若期望为基本类型，则不需要二次转化
			expect = test.Expect
		}
		// 分离预定义参数，调用插件
		p := fuzzTypes.Plugin{
			Name: pName,
			Args: test.Args[preNum:],
		}
		fmt.Println("test on: ", test)
		result := callPluginByType(inf.Type, p, preDefinedArgs...)
		fmt.Println("result: ", result)
		// 比较返回值与期望值
		passed := true
		if expect != nil {
			fmt.Println("expect: ", expect)
			if reflect.DeepEqual(expect, result) {
				fmt.Println("passed")
			} else {
				passed = false
				fmt.Println("failed")
			}
		}
		recordTest(test, result, passed)
	}
}

func runCmdRun(cmd *cobra.Command, _ []string) {
	common.SetCurrentCmd(Cmd.Use + " " + cmd.Use)
	expr, _ := cmd.Flags().GetString("expr")
	path, _ := cmd.Flags().GetString("path")
	outFile, _ := cmd.Flags().GetString("out")
	if outFile != "" {
		writeResultToFile = true
		defer writeTestTo(outFile)
	}
	if expr != "" {
		callPluginExpr(expr, path)
	} else {
		file, _ := cmd.Flags().GetString("file")
		if file == "" {
			common.FailExit("missing test data(-f or -e)")
		}
		callPluginTestFile(file, path)
	}
}
