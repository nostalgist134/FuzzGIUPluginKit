package test

import (
	"FuzzGIUPluginKit/cmd/common"
	"FuzzGIUPluginKit/convention"
	"encoding/json"
	"fmt"
	"github.com/nostalgist134/FuzzGIU/components/fuzzTypes"
	FGPlugin "github.com/nostalgist134/FuzzGIU/components/plugin"
	"github.com/spf13/cobra"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

var subCmdRun = &cobra.Command{
	Use:   "run",
	Short: "run test",
	Run:   runCmdRun,
}

func init() {
	subCmdRun.Flags().StringP("path", "p", "", "path of plugin binary file")
	subCmdRun.Flags().StringP("expr", "e", "",
		"call expression to be passed to plugin(name will be ignored, i suggest correct name, though)")
	subCmdRun.Flags().StringP("file", "f", "", "run test files generated by gen command")
}

// callPluginByType 根据插件类型调用插件函数
func callPluginByType(pType string, p fuzzTypes.Plugin, predefinedArgs ...any) any {
	switch pType {
	case convention.PluginTypes[convention.IndPTypePlProc]:
		return FGPlugin.PayloadProcessor(p)
	case convention.PluginTypes[convention.IndPTypePlGen]:
		return FGPlugin.PayloadGenerator(p)
	case convention.PluginTypes[convention.IndPTypeReact]:
		var req *fuzzTypes.Req
		var resp *fuzzTypes.Resp
		// 若指定了固定参数列表，则使用指定的，否则使用默认值，下面也一样
		if len(predefinedArgs) > 1 {
			req = predefinedArgs[0].(*fuzzTypes.Req)
			resp = predefinedArgs[1].(*fuzzTypes.Resp)
		} else {
			req = convention.GetFullStruct("*fuzzTypes.Req").(*fuzzTypes.Req)
			resp = convention.GetFullStruct("*fuzzTypes.Resp").(*fuzzTypes.Resp)
		}
		return FGPlugin.React(p, req, resp)
	case convention.PluginTypes[convention.IndPTypeReqSender]:
		var sendMeta *fuzzTypes.SendMeta
		if len(predefinedArgs) != 0 {
			sendMeta = predefinedArgs[0].(*fuzzTypes.SendMeta)
		} else {
			sendMeta = convention.GetStruct("*fuzzTypes.SendMeta").(*fuzzTypes.SendMeta)
		}
		return FGPlugin.SendRequest(p, sendMeta)
	case convention.PluginTypes[convention.IndPTypePreproc]:
		var fuzz *fuzzTypes.Fuzz
		if len(predefinedArgs) != 0 {
			fuzz = predefinedArgs[0].(*fuzzTypes.Fuzz)
		} else {
			fuzz = convention.GetStruct("*fuzzTypes.Fuzz").(*fuzzTypes.Fuzz)
		}
		return FGPlugin.Preprocess(p, fuzz)
	}
	return nil
}

// cmpParaTypes 判断参数列表的类型是否完全对应，是返回true，否则返回false
func cmpParaTypes(p1 []any, p2 []convention.Param) bool {
	if len(p1) != len(p2) {
		return false
	}
	for i, p := range p1 {
		if reflect.TypeOf(p).String() != p2[i].Type {
			return false
		}
	}
	return true
}

// callPluginExpr 使用伪函数调用语句调用插件（plugin1("1",2,3),plugin1("abc"),...），无法指定固定参数或期望值，只能使用默认值
func callPluginExpr(callExpr string, pluginPath string) {
	// FGPlugin包不会检查路径，所以可以用路径穿越绕过加载目录限制，我也懒得再把包重构一遍了，就这么着吧
	// 获取插件文件相关信息，存储穿越前的路径和穿越后的路径
	pName := filepath.Base(pluginPath)
	pName = pName[:strings.LastIndex(pName, ".")]
	pName1 := filepath.Join("../../", pName)
	plugins := FGPlugin.ParsePluginsStr(callExpr)
	inf, err := common.GetPluginInfo(pluginPath)
	common.FailExit(err)
	fd := convention.BuildFd(inf)
	preDefinedArgs := convention.GetPreDefinedArgs(inf.Type)
	// 测试插件
	for i, p := range plugins {
		argListCmp := p.Args
		if preDefinedArgs != nil {
			argListCmp = append(preDefinedArgs, argListCmp...)
		}
		if !cmpParaTypes(argListCmp, fd.Params) {
			fmt.Fprintf(os.Stderr, "arglist#%d arguments does not match plugin's, skipping\n", i)
		}
		// 穿越前的路径用于输出
		p.Name = pName
		fmt.Printf("test on: %v\n", p)
		// 穿越后的路径用于调用
		p.Name = pName1
		result := callPluginByType(inf.Type, p)
		fmt.Printf("result: %v\n", result)
	}
}

// callPluginTestFile 从文件中读取测试用例并执行
func callPluginTestFile(filePath string, pluginPath string) {
	pName := filepath.Base(pluginPath)
	pName = pName[:strings.LastIndex(pName, ".")]
	pName = filepath.Join("../../", pName)
	// 获取插件信息
	inf, err := common.GetPluginInfo(pluginPath)
	common.FailExit(err)
	fd := convention.BuildFd(inf)
	preDefinedArgs := convention.GetPreDefinedArgs(inf.Type)
	// 加载测试用例文件
	var tests []Test
	file, err := os.Open(filePath)
	common.FailExit(err)
	decoder := json.NewDecoder(file)
	// 使用json.Number类型表示数字，从而下面可以自动转换（json.Marshal默认对所有数字都是float64）
	decoder.UseNumber()
	err = decoder.Decode(&tests)
	common.FailExit(err)
	preNum := len(preDefinedArgs)
	for i, test := range tests {
		convertFail := false
		// 将map转为预定义参数对应的类型
		for j := 0; j < len(preDefinedArgs); j++ {
			b, _ := json.Marshal(test.Args[j])
			err = json.Unmarshal(b, preDefinedArgs[j])
			if err != nil {
				fmt.Fprintf(os.Stderr, "test#%d argument#%d conversion error: %v. skip\n", i, j, err)
				convertFail = true
				break
			}
			test.Args[j] = preDefinedArgs[j]
		}
		if convertFail {
			continue
		}
		// 将数字参数转换为正确的类型
		for j, a := range test.Args {
			switch v := a.(type) {
			case json.Number:
				if i64, err := v.Int64(); err == nil {
					test.Args[j] = int(i64)
				} else if f64, err := v.Float64(); err == nil {
					test.Args[j] = f64
				} else {
					test.Args[j] = v.String()
				}
			}
		}
		if !cmpParaTypes(test.Args, fd.Params) {
			fmt.Fprintf(os.Stderr, "test#%d arguments does not match plugin's, skip\n", i)
			continue
		}
		// 获取期望值（如果有）
		var expect any = nil
		if stru := convention.GetStruct(fd.RetType); test.Expect != nil && stru != nil {
			// 由json序列化对于any类型默认会转为map，需将map转为返回值对应的类型，并根据转换错误来判断类型是否匹配
			b, _ := json.Marshal(test.Expect)
			err = json.Unmarshal(b, stru)
			if err != nil {
				fmt.Fprintf(os.Stderr, "test#%d expect not match plugin's return type, skip comparation\n", i)
				continue
			}
			expect = stru
		} else if stru == nil && test.Expect != nil {
			// 若期望为基本类型，则不需要二次转化
			expect = test.Expect
		}
		// 分离预定义参数，调用插件
		p := fuzzTypes.Plugin{
			Name: pName,
			Args: test.Args[preNum:],
		}
		fmt.Println("test on: ", test)
		result := callPluginByType(inf.Type, p, preDefinedArgs...)
		fmt.Println("result: ", result)
		// 比较返回值与期望值
		if expect != nil {
			fmt.Println("expect: ", expect)
			if reflect.DeepEqual(expect, result) {
				fmt.Println("passed")
			} else {
				fmt.Println("failed")
			}
		}
	}
}

func runCmdRun(cmd *cobra.Command, _ []string) {
	common.SetCurrentCmd(Cmd.Use + " " + cmd.Use)
	expr, _ := cmd.Flags().GetString("expr")
	path, _ := cmd.Flags().GetString("path")
	if expr != "" {
		callPluginExpr(expr, path)
	} else {
		file, _ := cmd.Flags().GetString("file")
		if file == "" {
			common.FailExit("missing test data(-f or -e)")
		}
		callPluginTestFile(file, path)
	}
}
